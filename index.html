<!doctype html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Droppeteller – mobil (auto-ROI)</title>
  <style>
    html, body { margin:0; padding:0; background:#0b0b0f; color:#fff; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #app { display:flex; flex-direction:column; gap:8px; padding:10px; max-width:900px; margin:0 auto; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .card { background:#11131a; border:1px solid #232634; border-radius:14px; padding:10px; }
    label { font-size:14px; opacity:.9; }
    input, button, select { background:#0f1219; color:#fff; border:1px solid #2a2f3d; border-radius:10px; padding:8px 12px; font-size:14px; }
    button { cursor:pointer; }
    #video { display:none; width:100%; max-height:54vh; background:#000; border-radius:14px; }
    #canvas { width:100%; max-height:54vh; background:#000; border-radius:14px; }
    .metrics { display:grid; grid-template-columns:repeat(3, minmax(0,1fr)); gap:8px; }
    .metric { background:#0f1219; border:1px solid #2a2f3d; border-radius:14px; padding:10px; text-align:center; }
    .metric .v { font-size:24px; font-weight:700; }
    .metric .k { font-size:12px; opacity:.8; }
    .footer { font-size:12px; opacity:.7; }
    .badge { position:absolute; top:8px; left:8px; background:rgba(0,0,0,.55); padding:6px 10px; border-radius:10px; border:1px solid #2a2f3d; font-size:12px; }
    .corner { position:absolute; top:8px; right:8px; background:rgba(0,0,0,.55); padding:6px 10px; border-radius:10px; border:1px solid #2a2f3d; font-size:12px; }
    .togglebar { display:flex; gap:12px; align-items:center; font-size:12px; opacity:.95; flex-wrap:wrap; }
  </style>
</head>
<body>
  <div id="app">
    <div class="row" style="justify-content:space-between;">
      <div style="font-weight:700; font-size:18px;">Droppeteller – mobil (auto-ROI + sporing)</div>
      <div style="font-size:12px; opacity:.75;">Beta • Ikke medisinsk utstyr</div>
    </div>

    <div class="card">
      <div class="row">
        <button id="btnStart">Start kamera</button>
        <button id="btnToggle" disabled>Pause</button>
        <button id="btnReset" disabled>Nullstill</button>
        <select id="facing">
          <option value="environment" selected>Bak-kamera</option>
          <option value="user">Front-kamera</option>
        </select>
        <label>Modus:
          <select id="mode">
            <option value="auto" selected>Auto-ROI + sporing</option>
            <option value="manual">Manuell ROI</option>
          </select>
        </label>
      </div>
      <div class="row" style="margin-top:8px;">
        <label>Dråpefaktor (gtt/mL): <input id="dropFactor" type="number" value="20" step="1" min="5" max="120" style="width:90px"/></label>
        <label>Følsomhet:
          <select id="sensitivity">
            <option value="low">Lav</option>
            <option value="medium" selected>Middels</option>
            <option value="high">Høy</option>
          </select>
        </label>
        <div class="togglebar">
          <label><input type="checkbox" id="showContours" checked> Vis konturer</label>
          <label><input type="checkbox" id="showMask"> Vis maske (debug)</label>
          <label><input type="checkbox" id="showVideo"> Vis rå video (debug)</label>
        </div>
      </div>
      <div class="footer" id="status">Gi kameratilgang. Kantfarge på rammen viser sikkerhet (grønn/gul/rød). Grønn flash = registrert dråpe.</div>
    </div>

    <div class="card" style="position:relative;">
      <video id="video" playsinline muted></video>
      <canvas id="canvas"></canvas>
      <div id="badge" class="badge" style="display:none;"></div>
      <div id="corner" class="corner" style="display:none;"></div>
      <div class="metrics" style="margin-top:8px;">
        <div class="metric"><div class="v" id="mDrops">0</div><div class="k">Dråper</div></div>
        <div class="metric"><div class="v" id="mDpm">0.0</div><div class="k">DPM</div></div>
        <div class="metric"><div class="v" id="mMlh">0.0</div><div class="k">mL/h</div></div>
      </div>
    </div>
  </div>

  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script>
    // Vent til OpenCV runtime faktisk er klar
    function whenCvReady(){
      return new Promise(resolve => {
        if (window.cv && cv.Mat) return resolve();
        const check = () => { if (window.cv && cv.Mat) resolve(); else setTimeout(check, 50); };
        check();
      });
    }

    // --- UI helpers ---
    const $ = id => document.getElementById(id);
    const setStatus = (t, cls='') => { const s=$('status'); s.textContent=t; s.className='footer '+cls; };

    // --- State ---
    let video, canvas, ctx, stream;
    let capture=null, capCtx=null; // Offscreen buffer fra <video>
    let running=false, counting=false;
    let roi=null; // {x,y,w,h}
    let lastFrameROI=null; // cv.Mat (grå) for differanse i ROI
    let drops=0, emaDpm=null, lastDropMs=0, intervals=[];
    let minIntervalMs=250, emaAlpha=0.2;
    let searchTemplate=null, searchRect=null; // tracking
    let conf=0, lastAutoDetectMs=0, lastMatchScore=0;
    let flashMs=0, lastBlob=null;
    let offscreenMask=null; // for å vise bevegelsesmasken
    let contourRects=[]; let lineYCache=null;

    function showBadge(text){ const b=$('badge'); b.textContent=text; b.style.display='block'; clearTimeout(showBadge._t); showBadge._t=setTimeout(()=>b.style.display='none', 700); }
    function updateCorner(){ const c=$('corner'); const mode=$('mode').value; c.style.display='block'; c.textContent = `${mode==='auto'?'AUTO':'MANUAL'} | conf ${(conf*100|0)}%`; }
    const confColor = () => conf>=0.65?'rgba(56,214,107,.95)':(conf>=0.45?'rgba(255,209,102,.95)':'rgba(255,104,104,.95)');

    function updateSensitivity(){ const s=$('sensitivity').value; minIntervalMs = (s==='low')?350:(s==='high')?180:250; }
    const computeMlh=()=>{ const dpm=emaDpm||0; const df=parseFloat($('dropFactor').value||'20'); return (dpm/df)*60; };
    const updateMetrics=()=>{ $('mDrops').textContent=drops; $('mDpm').textContent=(emaDpm||0).toFixed(1); $('mMlh').textContent=computeMlh().toFixed(1); };

    async function startCamera(){
      await whenCvReady(); // sørg for at cv er klar før vi begynner å lese/tegne

      if (stream) stream.getTracks().forEach(t=>t.stop());
      const facingMode = $('facing').value;
      try{
        stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode, width:{ideal:1280}, height:{ideal:720} }, audio:false });
      } catch(e){ setStatus('Kunne ikke starte kamera: '+e.message,'warn'); return; }

      video.srcObject = stream;
      // Vent til video faktisk har data
      await video.play().catch(()=>{});
      if (video.readyState < 2) {
        await new Promise(res => video.onloadeddata = () => res());
      }

      // dimensjoner
      if (!capture){ capture=document.createElement('canvas'); }
      canvas = $('canvas'); ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth || 1280; canvas.height = video.videoHeight || 720;
      capture.width = canvas.width; capture.height = canvas.height; capCtx = capture.getContext('2d');

      $('btnToggle').disabled=false; $('btnReset').disabled=false; setStatus('Kamera i gang.');
      if (!offscreenMask){ offscreenMask = document.createElement('canvas'); }

      // Debug: vis rå video hvis avhukket
      $('showVideo').addEventListener('change', (e)=>{
        $('video').style.display = e.target.checked ? 'block' : 'none';
      });
    }

    function grabGrayFrame(){
      if (!video || video.readyState < 2) return null; // ingen rammer ennå
      // trekk en ramme fra video til offscreen capture
      capCtx.drawImage(video,0,0,capture.width,capture.height);
      const rgba = cv.imread(capture); // Fargeramme uten overlays
      const gray = new cv.Mat(); cv.cvtColor(rgba, gray, cv.COLOR_RGBA2GRAY);
      return {rgba, gray}; // caller MÅ slette begge
    }

    // --- Deteksjon 1: HSV-blå (koblinger/lokk) for å lokalisere kammeret ---
    function detectBlueCapsAndChamber(){
      const rgba = cv.imread(capture); // bruk offscreen uten overlays
      const hsv = new cv.Mat(); cv.cvtColor(rgba, hsv, cv.COLOR_RGBA2HSV);
      const low  = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [100, 80, 40, 0]);
      const high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [140,255,255,255]);
      const mask = new cv.Mat(); cv.inRange(hsv, low, high, mask);
      const kernel = cv.Mat.ones(5,5,cv.CV_8U); cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel); cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernel);
      const contours = new cv.MatVector(); const hierarchy = new cv.Mat();
      cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      let blobs=[]; for (let i=0;i<contours.size();i++){ const r=cv.boundingRect(contours.get(i)); const area=r.width*r.height; if(area<200) continue; blobs.push({x:r.x,y:r.y,w:r.width,h:r.height,cx:r.x+r.width/2, cy:r.y+r.height/2, area}); }
      blobs.sort((a,b)=>b.area-a.area);
      let out=null; if(blobs.length>=1){ const b1=blobs[0]; if(blobs.length>=2){ const b2=blobs[1]; const top=Math.min(b1.cy,b2.cy); const bottom=Math.max(b1.cy,b2.cy); const height=Math.max(80,(bottom-top)*1.6); const centerX=(b1.cx+b2.cx)/2; const width=Math.max(b1.w,b2.w)*2.4; const x=Math.max(0,Math.round(centerX-width/2)); const y=Math.max(0,Math.round(top-height*0.25)); const w=Math.min(canvas.width-x,Math.round(width)); const h=Math.min(canvas.height-y,Math.round(height)); out={x,y,w,h, conf:0.75}; } else { const width=Math.max(70,b1.w*1.9), height=Math.max(140,b1.h*5.5); const x=Math.max(0,Math.round(b1.cx-width/2)); const y=Math.max(0,Math.round(b1.cy-height*0.2)); const w=Math.min(canvas.width-x,Math.round(width)); const h=Math.min(canvas.height-y,Math.round(height)); out={x,y,w,h, conf:0.6}; } }
      rgba.delete(); hsv.delete(); low.delete(); high.delete(); mask.delete(); kernel.delete(); contours.delete(); hierarchy.delete();
      return out;
    }

    // --- Deteksjon 2: bevegelse (fallback) + vis maske i offscreenMask ---
    function autoDetectChamberMotion(gray){
      if (!autoDetectChamberMotion.prev){ autoDetectChamberMotion.prev = gray.clone(); return null; }
      const diff = new cv.Mat(); cv.absdiff(gray, autoDetectChamberMotion.prev, diff); gray.copyTo(autoDetectChamberMotion.prev);
      cv.GaussianBlur(diff, diff, new cv.Size(7,7), 0);
      const th=new cv.Mat(); cv.threshold(diff, th, 25, 255, cv.THRESH_BINARY);
      const kernel=cv.Mat.ones(3,3,cv.CV_8U); cv.morphologyEx(th, th, cv.MORPH_OPEN, kernel); cv.morphologyEx(th, th, cv.MORPH_CLOSE, kernel);
      try{ offscreenMask.width = th.cols; offscreenMask.height = th.rows; cv.imshow(offscreenMask, th); }catch{}
      const contours=new cv.MatVector(); const hierarchy=new cv.Mat(); cv.findContours(th, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      let best=null, bestScore=0; for (let i=0;i<contours.size();i++){ const r=cv.boundingRect(contours.get(i)); const area=r.width*r.height; const aspect=r.height/Math.max(1,r.width); if (area<(gray.rows*gray.cols)*0.002||area>(gray.rows*gray.cols)*0.25) continue; if (aspect<1.8) continue; const score=aspect*Math.sqrt(area); if (score>bestScore){bestScore=score; best=r;}}
      let out=null; if (best){ const padX=Math.round(best.width*0.25), padY=Math.round(best.height*0.1); const x=Math.max(0,best.x-padX); const y=Math.max(0,best.y-padY); const w=Math.min(gray.cols-x,best.width+padX*2); const h=Math.min(gray.rows-y,best.height+padY*2); out={x,y,w,h, conf:0.5}; }
      contours.delete(); hierarchy.delete(); th.delete(); diff.delete(); kernel.delete(); return out;
    }

    function updateTracker(gray){
      if (!roi) return;
      const r=new cv.Rect(roi.x,roi.y,Math.max(1,roi.w),Math.max(1,roi.h));
      if(!searchTemplate){ const inner=new cv.Rect(r.x+Math.floor(r.width*0.3), r.y, Math.max(5,Math.floor(r.width*0.4)), r.height); const roiStrip=gray.roi(inner); searchTemplate=roiStrip.clone(); roiStrip.delete(); searchRect=new cv.Rect(Math.max(0,r.x-Math.floor(r.width*0.35)), Math.max(0,r.y-Math.floor(r.height*0.2)), Math.min(gray.cols-r.x+Math.floor(r.width*0.35), Math.floor(r.width*1.7)), Math.min(gray.rows-r.y+Math.floor(r.height*0.2), Math.floor(r.height*1.4))); return; }
      const search=gray.roi(searchRect); const result=new cv.Mat(); result.create(search.rows-searchTemplate.rows+1, search.cols-searchTemplate.cols+1, cv.CV_32FC1); cv.matchTemplate(search,searchTemplate,result,cv.TM_CCOEFF_NORMED); const mm=cv.minMaxLoc(result); lastMatchScore=mm.maxVal; const topLeft=mm.maxLoc; const newX=searchRect.x+topLeft.x-Math.floor(roi.w*0.3); const newY=searchRect.y+topLeft.y; roi={x:Math.max(0,Math.min(gray.cols-roi.w,newX)), y:Math.max(0,Math.min(gray.rows-roi.h,newY)), w:roi.w, h:roi.h}; conf=lastMatchScore; search.delete(); result.delete(); const now=performance.now(); if(lastMatchScore<0.45||(now-lastAutoDetectMs)>2500){ searchTemplate.delete(); searchTemplate=null; lastAutoDetectMs=now; }
    }

    function processLoop(){
      if (!running) return;

      // Vent til video faktisk har rammer
      if (!video || video.readyState < 2) { requestAnimationFrame(processLoop); return; }

      contourRects.length=0;
      const frame = grabGrayFrame();
      if (!frame) { requestAnimationFrame(processLoop); return; }
      const {rgba:display, gray} = frame;
      const mode=$('mode').value;

      if (mode==='auto'){
        if(!roi || conf<0.55){ const byColor = detectBlueCapsAndChamber(); if (byColor){ roi={x:byColor.x,y:byColor.y,w:byColor.w,h:byColor.h}; conf=byColor.conf; searchTemplate&&(searchTemplate.delete(),searchTemplate=null); showBadge('Kammer (blå)'); } }
        if (roi) updateTracker(gray);
        if(!roi || conf<0.45){ const byMotion = autoDetectChamberMotion(gray); if(byMotion){ roi={x:byMotion.x,y:byMotion.y,w:byMotion.w,h:byMotion.h}; conf=Math.max(conf,byMotion.conf); showBadge('Kammer (bevegelse)'); } }
      } else {
        if (!roi){ const w=canvas.width,h=canvas.height; const rw=Math.round(w*0.22), rh=Math.round(h*0.78); const rx=Math.round((w-rw)/2), ry=Math.round((h-rh)/2); roi={x:rx,y:ry,w:rw,h:rh}; conf=0.5; setStatus('Manuell modus: plasser kammeret i rammen.'); }
      }

      // Telling i ROI
      lineYCache=null;
      if (roi){
        const r=new cv.Rect(roi.x,roi.y,Math.max(1,roi.w),Math.max(1,roi.h)); const roiGray=gray.roi(r);
        try{ const clahe=cv.createCLAHE(2.0, new cv.Size(8,8)); clahe.apply(roiGray, roiGray); clahe.delete(); }catch{}
        if(!lastFrameROI||lastFrameROI.cols!==roiGray.cols||lastFrameROI.rows!==roiGray.rows){ if(lastFrameROI) lastFrameROI.delete(); lastFrameROI=roiGray.clone(); }
        const diff=new cv.Mat(); cv.absdiff(roiGray,lastFrameROI,diff); roiGray.copyTo(lastFrameROI);
        const th=new cv.Mat(); cv.GaussianBlur(diff,diff,new cv.Size(5,5),0); cv.threshold(diff,th,20,255,cv.THRESH_BINARY);
        const kernel=cv.Mat.ones(3,3,cv.CV_8U); cv.morphologyEx(th,th,cv.MORPH_OPEN,kernel); cv.morphologyEx(th,th,cv.MORPH_CLOSE,kernel);
        const contours=new cv.MatVector(); const hierarchy=new cv.Mat(); cv.findContours(th,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
        const lineY=roi.y+Math.round(roi.h*0.6); lineYCache=lineY; const nowMs=performance.now();
        for(let i=0;i<contours.size();i++){ const rect=cv.boundingRect(contours.get(i)); const area=rect.width*rect.height; if(area<20||rect.height<6||rect.height>roi.h*0.6) continue; const cx=rect.x+rect.width/2+roi.x; const cy=rect.y+rect.height/2+roi.y; contourRects.push({x:rect.x+roi.x,y:rect.y+roi.y,w:rect.width,h:rect.height,cx,cy}); if(Math.abs(cy-lineY)<=5){ if(nowMs-lastDropMs>=minIntervalMs){ if(window._prevEventMs===undefined) window._prevEventMs=nowMs; else { const dt=nowMs-window._prevEventMs; window._prevEventMs=nowMs; if(dt>=150&&dt<=8000){ intervals.push(dt); if(intervals.length>10) intervals.shift(); const instDpm=60000.0/dt; emaDpm=(emaDpm==null)?instDpm:(emaAlpha*instDpm + (1-emaAlpha)*emaDpm); } } drops+=1; lastDropMs=nowMs; updateMetrics(); flashMs=220; lastBlob={cx,cy,rect:{x:rect.x+roi.x,y:rect.y+roi.y,w:rect.width,h:rect.height}}; } } }
        contours.delete(); hierarchy.delete(); kernel.delete(); th.delete(); diff.delete(); roiGray.delete();
      }

      // 1) vis videorammen på canvas
      cv.imshow(canvas, display);

      // 2) tegn overlays
      const g=canvas.getContext('2d');
      if ($('showMask').checked && offscreenMask && offscreenMask.width>0){ const w=Math.round(canvas.width*0.22); const h=Math.round(offscreenMask.height*(w/offscreenMask.width)); g.save(); g.globalAlpha=0.8; g.drawImage(offscreenMask, 10, 10, w, h); g.restore(); }
      if ($('showContours').checked){ for(const r of contourRects){ g.save(); g.strokeStyle='rgba(0,200,255,.95)'; g.lineWidth=2; g.strokeRect(r.x,r.y,r.w,r.h); g.beginPath(); g.arc(r.cx,r.cy,5,0,Math.PI*2); g.stroke(); g.restore(); } }
      if (roi){ g.save(); g.strokeStyle=confColor(); g.lineWidth=4; g.strokeRect(roi.x,roi.y,roi.w,roi.h); if(lineYCache!=null){ g.strokeStyle='rgba(0,255,255,.95)'; g.beginPath(); g.moveTo(roi.x,lineYCache); g.lineTo(roi.x+roi.w,lineYCache); g.stroke(); } g.restore(); }
      if (flashMs>0){ g.save(); g.fillStyle='rgba(56,214,107,0.18)'; g.fillRect(0,0,canvas.width,canvas.height); if(lastBlob){ const t=1-(flashMs/220); const radius=10+t*60; g.beginPath(); g.arc(lastBlob.cx,lastBlob.cy,radius,0,Math.PI*2); g.strokeStyle='rgba(56,214,107,'+(0.9*(1-t))+')'; g.lineWidth=3; g.stroke(); } g.restore(); flashMs-=16; }
      updateCorner();

      // 3) rydde opp mats
      display.delete(); gray.delete();

      if (counting) requestAnimationFrame(processLoop); else running=false;
    }

    function toggleCounting(){ if(!stream) return; counting=!counting; $('btnToggle').textContent=counting?'Pause':'Start'; if(counting){ running=true; requestAnimationFrame(processLoop);} }
    function resetAll(){ drops=0; emaDpm=null; intervals.length=0; lastDropMs=0; window._prevEventMs=undefined; updateMetrics(); searchTemplate&&searchTemplate.delete(); searchTemplate=null; roi=null; setStatus('Nullstilt.'); lastBlob=null; flashMs=0; conf=0; contourRects.length=0; }

    // init UI
    window.addEventListener('DOMContentLoaded', () => {
      video=$('video'); canvas=$('canvas'); ctx=canvas.getContext('2d');
      $('btnStart').onclick = async()=>{ await startCamera(); counting=true; running=true; updateSensitivity(); requestAnimationFrame(processLoop); };
      $('btnToggle').onclick = toggleCounting; $('btnReset').onclick = resetAll;
      $('dropFactor').onchange = updateMetrics; $('sensitivity').onchange = updateSensitivity; $('facing').onchange = startCamera;
      $('mode').onchange = ()=>{ roi=null; searchTemplate&&searchTemplate.delete(); searchTemplate=null; setStatus($('mode').value==='auto'?'Auto-modus aktiv.':'Manuell modus: plasser kammeret i rammen.'); };
    });
  </script>
</body>
</html>
