<!doctype html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Droppeteller – mobil (auto-ROI)</title>
  <style>
    html, body { margin:0; padding:0; background:#0b0b0f; color:#fff; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #app { display:flex; flex-direction:column; gap:8px; padding:10px; max-width:900px; margin:0 auto; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .card { background:#11131a; border:1px solid #232634; border-radius:14px; padding:10px; }
    label { font-size:14px; opacity:.9; }
    input, button, select { background:#0f1219; color:#fff; border:1px solid #2a2f3d; border-radius:10px; padding:8px 12px; font-size:14px; }
    button { cursor:pointer; }
    #video, #canvas { width:100%; max-height:54vh; background:#000; border-radius:14px; }
    .metrics { display:grid; grid-template-columns:repeat(3, minmax(0,1fr)); gap:8px; }
    .metric { background:#0f1219; border:1px solid #2a2f3d; border-radius:14px; padding:10px; text-align:center; }
    .metric .v { font-size:24px; font-weight:700; }
    .metric .k { font-size:12px; opacity:.8; }
    .footer { font-size:12px; opacity:.7; }
    .badge { position:absolute; top:8px; left:8px; background:rgba(0,0,0,.55); padding:6px 10px; border-radius:10px; border:1px solid #2a2f3d; font-size:12px; }
    .corner { position:absolute; top:8px; right:8px; background:rgba(0,0,0,.55); padding:6px 10px; border-radius:10px; border:1px solid #2a2f3d; font-size:12px; }
    .legend { position:absolute; bottom:8px; left:8px; background:rgba(0,0,0,.55); padding:6px 10px; border-radius:10px; border:1px solid #2a2f3d; font-size:12px; }
    .dot { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; }
  </style>
</head>
<body>
  <div id="app">
    <div class="row" style="justify-content:space-between;">
      <div style="font-weight:700; font-size:18px;">Droppeteller – mobil (auto-ROI + sporing)</div>
      <div style="font-size:12px; opacity:.75;">Beta • Ikke medisinsk utstyr</div>
    </div>

    <div class="card">
      <div class="row">
        <button id="btnStart">Start kamera</button>
        <button id="btnToggle" disabled>Pause</button>
        <button id="btnReset" disabled>Nullstill</button>
        <select id="facing">
          <option value="environment" selected>Bak-kamera</option>
          <option value="user">Front-kamera</option>
        </select>
        <label>Modus:
          <select id="mode">
            <option value="auto" selected>Auto-ROI + sporing</option>
            <option value="manual">Manuell ROI</option>
          </select>
        </label>
      </div>
      <div class="row" style="margin-top:8px;">
        <label>Dråpefaktor (gtt/mL): <input id="dropFactor" type="number" value="20" step="1" min="5" max="120" style="width:90px"/></label>
        <label>Følsomhet:
          <select id="sensitivity">
            <option value="low">Lav</option>
            <option value="medium" selected>Middels</option>
            <option value="high">Høy</option>
          </select>
        </label>
      </div>
      <div class="footer" id="status">Gi kameratilgang. Auto-modus finner og følger dråpekammeret. Kantfarge = trygghet (grønn: høy, gul: middels, rød: lav). Grønn flash = registrert dråpe.</div>
    </div>

    <div class="card" style="position:relative;">
      <video id="video" playsinline muted></video>
      <canvas id="canvas"></canvas>
      <div id="badge" class="badge" style="display:none;"></div>
      <div id="corner" class="corner" style="display:none;"></div>
      <div id="legend" class="legend" style="display:block;">
        <div><span class="dot" style="background:#38d66b"></span>Høy sikkerhet (≥ 65%)</div>
        <div><span class="dot" style="background:#ffd166"></span>Middels sikkerhet (45–64%)</div>
        <div><span class="dot" style="background:#ff6868"></span>Lav sikkerhet (&lt; 45%)</div>
      </div>
      <div class="metrics" style="margin-top:8px;">
        <div class="metric"><div class="v" id="mDrops">0</div><div class="k">Dråper</div></div>
        <div class="metric"><div class="v" id="mDpm">0.0</div><div class="k">DPM</div></div>
        <div class="metric"><div class="v" id="mMlh">0.0</div><div class="k">mL/h</div></div>
      </div>
    </div>
  </div>

  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
  <script>
    // --- UI helpers ---
    const $ = id => document.getElementById(id);
    const setStatus = (t, cls='') => { const s=$('status'); s.textContent=t; s.className='footer '+cls; };

    // --- State ---
    let video, canvas, ctx, stream;
    let running=false, counting=false;
    let roi=null; // {x,y,w,h}
    let lastFrameROI=null; // cv.Mat for differanse i ROI
    let drops=0, emaDpm=null, lastDropMs=0, intervals=[];
    let minIntervalMs=250, emaAlpha=0.2;
    let searchTemplate=null, searchRect=null, lastMatchScore=0;
    let lastAutoDetectMs=0;
    let flashMs=0; // flash ved dropp
    let lastBlob = null; // {cx, cy, rect}
    let offscreenMask = null; // miniatyr av bevegelsesmaske
    let conf=0; // 0..1, samlet trygghet for ROI
    let contourRects = []; // samle konturer for tegning etter imshow
    let lineYCache = null;

    function showBadge(text){ const b=$('badge'); b.textContent=text; b.style.display='block'; clearTimeout(showBadge._t); showBadge._t=setTimeout(()=>b.style.display='none', 700); }

    function updateCorner(){
      const c=$('corner');
      const mode=$('mode').value;
      c.style.display='block';
      c.textContent = `${mode==='auto'?'AUTO':'MANUAL'}  |  conf ${(conf*100|0)}%`;
    }

    function confColor(){
      if (conf>=0.65) return 'rgba(56,214,107,.95)'; // grønn
      if (conf>=0.45) return 'rgba(255,209,102,.95)'; // gul
      return 'rgba(255,104,104,.95)'; // rød
    }

    function updateSensitivity(){
      const s=$('sensitivity').value;
      minIntervalMs = (s==='low')?350:(s==='high')?180:250;
    }
    function computeMlh(){ const dpm=emaDpm||0; const df=parseFloat($('dropFactor').value||'20'); return (dpm/df)*60; }
    function updateMetrics(){ $('mDrops').textContent=drops; $('mDpm').textContent=(emaDpm||0).toFixed(1); $('mMlh').textContent=computeMlh().toFixed(1); }

    async function startCamera(){
      if (stream) stream.getTracks().forEach(t=>t.stop());
      const facingMode = $('facing').value;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode, width:{ideal:1280}, height:{ideal:720} }, audio:false });
      } catch(e){ setStatus('Kunne ikke starte kamera: '+e.message,'warn'); return; }
      video.srcObject = stream; await video.play();
      canvas.width = video.videoWidth; canvas.height = video.videoHeight;
      $('btnToggle').disabled=false; $('btnReset').disabled=false;
      setStatus('Kamera i gang. Auto-modus søker etter dråpekammer.');
      if (!offscreenMask){ offscreenMask = document.createElement('canvas'); }
    }

    function grabGrayFrame(){
      ctx.drawImage(video,0,0,canvas.width,canvas.height);
      const rgba = cv.imread(canvas);
      const gray = new cv.Mat();
      cv.cvtColor(rgba, gray, cv.COLOR_RGBA2GRAY);
      rgba.delete();
      return gray; // caller must delete
    }

    // --- Auto-ROI: finn høy, smal bevegelsesregion (dråpekammer) ---
    function autoDetectChamber(gray){
      if (!autoDetectChamber.prev){ autoDetectChamber.prev = gray.clone(); return null; }
      const diff = new cv.Mat();
      cv.absdiff(gray, autoDetectChamber.prev, diff);
      gray.copyTo(autoDetectChamber.prev);

      cv.GaussianBlur(diff, diff, new cv.Size(7,7), 0);
      const th = new cv.Mat();
      cv.threshold(diff, th, 25, 255, cv.THRESH_BINARY);
      const kernel = cv.Mat.ones(3,3, cv.CV_8U);
      cv.morphologyEx(th, th, cv.MORPH_OPEN, kernel);
      cv.morphologyEx(th, th, cv.MORPH_CLOSE, kernel);

      // lagre mask for miniatyr, men tegn ETTER imshow
      autoDetectChamber._lastMask = th.clone();

      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(th, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let best=null, bestScore=0;
      for (let i=0;i<contours.size();i++){
        const r = cv.boundingRect(contours.get(i));
        const area = r.width*r.height;
        const aspect = r.height / Math.max(1,r.width);
        if (area < (gray.rows*gray.cols)*0.002 || area > (gray.rows*gray.cols)*0.25) continue;
        if (aspect < 1.8) continue;
        const centerY = r.y + r.height/2; const cyScore = 1.0 - Math.abs(centerY - gray.rows*0.55)/(gray.rows*0.55);
        const score = 0.6*aspect + 0.3*Math.sqrt(area) + 0.1*cyScore;
        if (score > bestScore){ bestScore=score; best=r; }
      }

      contours.delete(); hierarchy.delete(); diff.delete(); kernel.delete();
      // th beholdes i _lastMask

      if (!best) return null;
      const norm = Math.min(1, bestScore / 20);
      const padX = Math.round(best.width*0.25), padY = Math.round(best.height*0.1);
      const x = Math.max(0, best.x - padX);
      const y = Math.max(0, best.y - padY);
      const w = Math.min(gray.cols - x, best.width + padX*2);
      const h = Math.min(gray.rows - y, best.height + padY*2);
      return {x,y,w,h, conf:norm};
    }

    // --- Template matching sporing rundt forrige ROI ---
    function updateTracker(gray){
      if (!roi) return;
      const r = new cv.Rect(roi.x, roi.y, Math.max(1,roi.w), Math.max(1,roi.h));
      if (!searchTemplate){
        const inner = new cv.Rect(r.x + Math.floor(r.width*0.3), r.y, Math.max(5, Math.floor(r.width*0.4)), r.height);
        const roiStrip = gray.roi(inner);
        searchTemplate = roiStrip.clone();
        roiStrip.delete();
        searchRect = new cv.Rect(
          Math.max(0, r.x - Math.floor(r.width*0.35)),
          Math.max(0, r.y - Math.floor(r.height*0.2)),
          Math.min(gray.cols - r.x + Math.floor(r.width*0.35), Math.floor(r.width*1.7)),
          Math.min(gray.rows - r.y + Math.floor(r.height*0.2), Math.floor(r.height*1.4))
        );
        return;
      }
      const search = gray.roi(searchRect);
      const result = new cv.Mat();
      result.create(search.rows - searchTemplate.rows + 1, search.cols - searchTemplate.cols + 1, cv.CV_32FC1);
      cv.matchTemplate(search, searchTemplate, result, cv.TM_CCOEFF_NORMED);
      const minMax = cv.minMaxLoc(result);
      lastMatchScore = minMax.maxVal; // 0..1
      const topLeft = minMax.maxLoc;
      const newX = searchRect.x + topLeft.x - Math.floor(roi.w*0.3);
      const newY = searchRect.y + topLeft.y;
      roi = { x: Math.max(0, Math.min(gray.cols - roi.w, newX)), y: Math.max(0, Math.min(gray.rows - roi.h, newY)), w: roi.w, h: roi.h };
      conf = lastMatchScore;
      search.delete(); result.delete();

      const now = performance.now();
      if (lastMatchScore < 0.45 || (now - lastAutoDetectMs) > 2500){
        searchTemplate.delete(); searchTemplate = null; lastAutoDetectMs = now;
      }
    }

    function processLoop(){
      if (!running) return;
      contourRects.length = 0; // reset visuelle markeringer for denne rammen
      const gray = grabGrayFrame();
      let display = cv.imread(canvas); // RGBA snapshot for imshow

      const mode = $('mode').value;
      const now = performance.now();

      if (mode === 'auto'){
        if (roi) updateTracker(gray);
        if (!roi || conf < 0.45){
          const det = autoDetectChamber(gray);
          if (det) { roi = {x:det.x,y:det.y,w:det.w,h:det.h}; conf = det.conf; searchTemplate && (searchTemplate.delete(), searchTemplate=null); lastAutoDetectMs = now; setStatus('Fant dråpekammer automatisk.'); showBadge('Fant kammer'); }
        }
      } else {
        if (!roi){
          const w = canvas.width, h = canvas.height;
          const rw = Math.round(w*0.22), rh = Math.round(h*0.78);
          const rx = Math.round((w-rw)/2), ry = Math.round((h-rh)/2);
          roi = {x:rx, y:ry, w:rw, h:rh};
          conf = 0.5;
          setStatus('Manuell modus: plasser kammeret innenfor rammen.');
        }
      }

      // droppetelling innenfor ROI (frame differencing i ROI)
      lineYCache = null;
      if (roi){
        const r = new cv.Rect(roi.x, roi.y, Math.max(1,roi.w), Math.max(1,roi.h));
        const roiGray = gray.roi(r);

        if (!lastFrameROI || lastFrameROI.cols!==roiGray.cols || lastFrameROI.rows!==roiGray.rows){
          if (lastFrameROI) lastFrameROI.delete();
          lastFrameROI = roiGray.clone();
        }
        const diff = new cv.Mat();
        cv.absdiff(roiGray, lastFrameROI, diff);
        roiGray.copyTo(lastFrameROI);
        const th = new cv.Mat();
        cv.GaussianBlur(diff, diff, new cv.Size(5,5), 0);
        cv.threshold(diff, th, 25, 255, cv.THRESH_BINARY);
        const kernel = cv.Mat.ones(3,3, cv.CV_8U);
        cv.morphologyEx(th, th, cv.MORPH_OPEN, kernel);
        cv.morphologyEx(th, th, cv.MORPH_CLOSE, kernel);
        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();
        cv.findContours(th, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        const lineY = roi.y + Math.round(roi.h*0.6);
        lineYCache = lineY;
        const nowMs = performance.now();
        for (let i=0;i<contours.size();i++){
          const rect = cv.boundingRect(contours.get(i));
          const area = rect.width*rect.height;
          if (area < 20 || rect.height < 6 || rect.height > roi.h*0.6) continue;
          const cx = rect.x + rect.width/2 + roi.x;
          const cy = rect.y + rect.height/2 + roi.y;
          contourRects.push({x:rect.x+roi.x, y:rect.y+roi.y, w:rect.width, h:rect.height, cx, cy});

          if (Math.abs(cy - lineY) <= 5){
            if (nowMs - lastDropMs >= minIntervalMs){
              if (window._prevEventMs === undefined) window._prevEventMs = nowMs; else {
                const dt = nowMs - window._prevEventMs; window._prevEventMs = nowMs;
                if (dt >= 150 && dt <= 8000){
                  intervals.push(dt); if (intervals.length>10) intervals.shift();
                  const instDpm = 60000.0/dt;
                  emaDpm = (emaDpm==null)?instDpm:(emaAlpha*instDpm + (1-emaAlpha)*emaDpm);
                }
              }
              drops += 1; lastDropMs = nowMs; updateMetrics();
              flashMs = 240;
              lastBlob = {cx, cy, rect:{x:rect.x+roi.x, y:rect.y+roi.y, w:rect.width, h:rect.height}};
            }
          }
        }

        contours.delete(); hierarchy.delete(); kernel.delete(); th.delete(); diff.delete(); roiGray.delete();
      }

      // 1) Tegn selve kamerabildet først
      cv.imshow(canvas, display); display.delete(); gray.delete();

      // 2) Tegn ALLE overlegg etterpå (ellers blir de overskrevet av imshow)
      const g = canvas.getContext('2d');

      // mask-miniatyr
      if (autoDetectChamber._lastMask){
        try{
          const tmp = document.createElement('canvas');
          tmp.width = autoDetectChamber._lastMask.cols; tmp.height = autoDetectChamber._lastMask.rows;
          cv.imshow(tmp, autoDetectChamber._lastMask);
          const w = Math.round(canvas.width*0.22);
          const h = Math.round(tmp.height * (w/tmp.width));
          g.save(); g.globalAlpha = 0.8; g.drawImage(tmp, 10, 10, w, h); g.restore();
        }catch{}
      }

      // konturmarkeringer
      for (const r of contourRects){
        g.save(); g.strokeStyle='rgba(0,200,255,.95)'; g.lineWidth=2; g.strokeRect(r.x, r.y, r.w, r.h); g.beginPath(); g.arc(r.cx, r.cy, 5, 0, Math.PI*2); g.stroke(); g.restore();
      }

      // ROI-ramme + tellelinje
      if (roi){
        g.save();
        g.strokeStyle = confColor(); g.lineWidth = 4; g.strokeRect(roi.x, roi.y, roi.w, roi.h);
        if (lineYCache!=null){ g.strokeStyle='rgba(0,255,255,.95)'; g.beginPath(); g.moveTo(roi.x, lineYCache); g.lineTo(roi.x+roi.w, lineYCache); g.stroke(); }
        g.restore();
      }

      // dråpe-flash + bølge
      if (flashMs > 0){
        g.save();
        g.fillStyle='rgba(56,214,107,0.18)'; g.fillRect(0,0,canvas.width,canvas.height);
        if (lastBlob){ const t = 1 - (flashMs/240); const radius = 10 + t*60; g.beginPath(); g.arc(lastBlob.cx, lastBlob.cy, radius, 0, Math.PI*2); g.strokeStyle='rgba(56,214,107,'+(0.9*(1-t))+')'; g.lineWidth=3; g.stroke(); }
        g.restore();
        flashMs -= 16;
      }

      // hjørne-info
      updateCorner();

      if (counting) requestAnimationFrame(processLoop); else running=false;
    }

    function toggleCounting(){ if (!stream) return; counting=!counting; $('btnToggle').textContent = counting?'Pause':'Start'; if (counting){ running=true; requestAnimationFrame(processLoop);} }
    function resetAll(){ drops=0; emaDpm=null; intervals.length=0; lastDropMs=0; window._prevEventMs=undefined; updateMetrics(); searchTemplate&&searchTemplate.delete(); searchTemplate=null; roi=null; setStatus('Nullstilt.'); lastBlob=null; flashMs=0; conf=0; contourRects.length=0; }

    function onOpenCvReady(){ window.onOpenCvReady = () => setStatus('OpenCV.js lastet. Start kamera.'); }

    // init UI
    window.addEventListener('DOMContentLoaded', () => {
      video=$('video'); canvas=$('canvas'); ctx=canvas.getContext('2d');
      $('btnStart').onclick = async()=>{ await startCamera(); counting=true; running=true; updateSensitivity(); requestAnimationFrame(processLoop); };
      $('btnToggle').onclick = toggleCounting; $('btnReset').onclick = resetAll;
      $('dropFactor').onchange = updateMetrics; $('sensitivity').onchange = updateSensitivity; $('facing').onchange = startCamera;
      $('mode').onchange = ()=>{ roi=null; searchTemplate&&searchTemplate.delete(); searchTemplate=null; setStatus($('mode').value==='auto'?'Auto-modus aktiv.':'Manuell modus: plasser kammeret innenfor rammen.'); };
    });
  </script>
</body>
</html>
