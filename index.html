<!doctype html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Droppeteller – mobil (auto-ROI)</title>
  <style>
    html, body { margin:0; padding:0; background:#0b0b0f; color:#fff; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #app { display:flex; flex-direction:column; gap:8px; padding:10px; max-width:900px; margin:0 auto; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .card { background:#11131a; border:1px solid #232634; border-radius:14px; padding:10px; }
    label { font-size:14px; opacity:.9; }
    input, button, select { background:#0f1219; color:#fff; border:1px solid #2a2f3d; border-radius:10px; padding:8px 12px; font-size:14px; }
    button { cursor:pointer; }
    #video, #canvas { width:100%; max-height:54vh; background:#000; border-radius:14px; }
    .metrics { display:grid; grid-template-columns:repeat(3, minmax(0,1fr)); gap:8px; }
    .metric { background:#0f1219; border:1px solid #2a2f3d; border-radius:14px; padding:10px; text-align:center; }
    .metric .v { font-size:24px; font-weight:700; }
    .metric .k { font-size:12px; opacity:.8; }
    .footer { font-size:12px; opacity:.7; }
    .badge { position:absolute; top:8px; left:8px; background:rgba(0,0,0,.55); padding:6px 10px; border-radius:10px; border:1px solid #2a2f3d; font-size:12px; }
    .corner { position:absolute; top:8px; right:8px; background:rgba(0,0,0,.55); padding:6px 10px; border-radius:10px; border:1px solid #2a2f3d; font-size:12px; }
    .togglebar { display:flex; gap:8px; align-items:center; font-size:12px; opacity:.85; }
  </style>
</head>
<body>
  <div id="app">
    <div class="row" style="justify-content:space-between;">
      <div style="font-weight:700; font-size:18px;">Droppeteller – mobil (auto-ROI + sporing)</div>
      <div style="font-size:12px; opacity:.75;">Beta • Ikke medisinsk utstyr</div>
    </div>

    <div class="card">
      <div class="row">
        <button id="btnStart">Start kamera</button>
        <button id="btnToggle" disabled>Pause</button>
        <button id="btnReset" disabled>Nullstill</button>
        <select id="facing">
          <option value="environment" selected>Bak-kamera</option>
          <option value="user">Front-kamera</option>
        </select>
        <label>Modus:
          <select id="mode">
            <option value="auto" selected>Auto-ROI + sporing</option>
            <option value="manual">Manuell ROI</option>
          </select>
        </label>
      </div>
      <div class="row" style="margin-top:8px;">
        <label>Dråpefaktor (gtt/mL): <input id="dropFactor" type="number" value="20" step="1" min="5" max="120" style="width:90px"/></label>
        <label>Følsomhet:
          <select id="sensitivity">
            <option value="low">Lav</option>
            <option value="medium" selected>Middels</option>
            <option value="high">Høy</option>
          </select>
        </label>
        <div class="togglebar">
          <label><input type="checkbox" id="showContours" checked> Vis konturer</label>
          <label><input type="checkbox" id="showMask"> Vis maske (debug)</label>
        </div>
      </div>
      <div class="footer" id="status">Gi kameratilgang. Kantfarge på rammen viser sikkerhet (grønn/gul/rød). Grønn flash = registrert dråpe.</div>
    </div>

    <div class="card" style="position:relative;">
      <video id="video" playsinline muted></video>
      <canvas id="canvas"></canvas>
      <div id="badge" class="badge" style="display:none;"></div>
      <div id="corner" class="corner" style="display:none;"></div>
      <div class="metrics" style="margin-top:8px;">
        <div class="metric"><div class="v" id="mDrops">0</div><div class="k">Dråper</div></div>
        <div class="metric"><div class="v" id="mDpm">0.0</div><div class="k">DPM</div></div>
        <div class="metric"><div class="v" id="mMlh">0.0</div><div class="k">mL/h</div></div>
      </div>
    </div>
  </div>

  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
  <script>
    // --- UI helpers ---
    const $ = id => document.getElementById(id);
    const setStatus = (t, cls='') => { const s=$('status'); s.textContent=t; s.className='footer '+cls; };

    // --- State ---
    let video, canvas, ctx, stream;
    let running=false, counting=false;
    let roi=null; // {x,y,w,h}
    let lastFrameROI=null; // cv.Mat for differanse i ROI
    let drops=0, emaDpm=null, lastDropMs=0, intervals=[];
    let minIntervalMs=250, emaAlpha=0.2;
    let searchTemplate=null, searchRect=null, lastMatchScore=0;
    let lastAutoDetectMs=0;
    let flashMs=0; let lastBlob = null;
    let offscreenMask=null; let conf=0; let contourRects=[]; let lineYCache=null;

    function showBadge(text){ const b=$('badge'); b.textContent=text; b.style.display='block'; clearTimeout(showBadge._t); showBadge._t=setTimeout(()=>b.style.display='none', 700); }
    function updateCorner(){ const c=$('corner'); const mode=$('mode').value; c.style.display='block'; c.textContent = `${mode==='auto'?'AUTO':'MANUAL'} | conf ${(conf*100|0)}%`; }
    const confColor = () => conf>=0.65?'rgba(56,214,107,.95)':(conf>=0.45?'rgba(255,209,102,.95)':'rgba(255,104,104,.95)');

    function updateSensitivity(){ const s=$('sensitivity').value; minIntervalMs = (s==='low')?350:(s==='high')?180:250; }
    const computeMlh=()=>{ const dpm=emaDpm||0; const df=parseFloat($('dropFactor').value||'20'); return (dpm/df)*60; };
    const updateMetrics=()=>{ $('mDrops').textContent=drops; $('mDpm').textContent=(emaDpm||0).toFixed(1); $('mMlh').textContent=computeMlh().toFixed(1); };

    async function startCamera(){
      if (stream) stream.getTracks().forEach(t=>t.stop());
      const facingMode = $('facing').value;
      try{ stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode, width:{ideal:1280}, height:{ideal:720} }, audio:false }); }
      catch(e){ setStatus('Kunne ikke starte kamera: '+e.message,'warn'); return; }
      video.srcObject = stream; await video.play();
      canvas.width = video.videoWidth; canvas.height = video.videoHeight;
      $('btnToggle').disabled=false; $('btnReset').disabled=false; setStatus('Kamera i gang.');
      if (!offscreenMask){ offscreenMask = document.createElement('canvas'); }
    }

    function grabGrayFrame(){ ctx.drawImage(video,0,0,canvas.width,canvas.height); const rgba=cv.imread(canvas); const gray=new cv.Mat(); cv.cvtColor(rgba,gray,cv.COLOR_RGBA2GRAY); rgba.delete(); return gray; }

    // --- NY: Farge-basert kammerdeteksjon (HSV blå plast) ---
    function detectBlueCapsAndChamber(){
      // Bruk snapshot fra canvas
      const rgba = cv.imread(canvas);
      const hsv = new cv.Mat();
      cv.cvtColor(rgba, hsv, cv.COLOR_RGBA2HSV);
      // grov blå-range (kan justeres): H 100-140, S 80-255, V 40-255
      const low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [100,80,40,0]);
      const high= new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [140,255,255,255]);
      const mask = new cv.Mat();
      cv.inRange(hsv, low, high, mask);
      const kernel = cv.Mat.ones(5,5,cv.CV_8U);
      cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);
      cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernel);
      const contours = new cv.MatVector(); const hierarchy = new cv.Mat();
      cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      // plukk 1-2 største blå komponenter som sannsynlige endestykker/koblinger
      let blobs=[];
      for (let i=0;i<contours.size();i++){
        const r=cv.boundingRect(contours.get(i)); const area=r.width*r.height;
        if (area<200) continue; // filtrer små
        blobs.push({x:r.x,y:r.y,w:r.width,h:r.height,cx:r.x+r.width/2, cy:r.y+r.height/2, area});
      }
      blobs.sort((a,b)=>b.area-a.area);
      let result=null;
      if (blobs.length>=1){
        const b1=blobs[0];
        if (blobs.length>=2){
          const b2=blobs[1];
          // bygg kammer-ROI mellom senterpunktene vertikalt
          const top = Math.min(b1.cy,b2.cy); const bottom=Math.max(b1.cy,b2.cy);
          const height = Math.max(60, (bottom-top)*1.4);
          const centerX = (b1.cx+b2.cx)/2; const width = Math.max(b1.w,b2.w)*2.2;
          const x = Math.max(0, Math.round(centerX - width/2));
          const y = Math.max(0, Math.round(top - height*0.25));
          const w = Math.min(canvas.width - x, Math.round(width));
          const h = Math.min(canvas.height - y, Math.round(height));
          result={x,y,w,h, conf:0.75};
        } else {
          // ett blått punkt – lag en høy, smal boks under
          const width = Math.max(60, b1.w*1.8); const height = Math.max(120, b1.h*5);
          const x = Math.max(0, Math.round(b1.cx - width/2));
          const y = Math.max(0, Math.round(b1.cy - height*0.2));
          const w = Math.min(canvas.width - x, Math.round(width));
          const h = Math.min(canvas.height - y, Math.round(height));
          result={x,y,w,h, conf:0.6};
        }
      }

      // rydde
      rgba.delete(); hsv.delete(); low.delete(); high.delete(); mask.delete(); kernel.delete(); contours.delete(); hierarchy.delete();
      return result; // kan være null
    }

    // Auto-ROI via bevegelse (fallback)
    function autoDetectChamberMotion(gray){
      if (!autoDetectChamberMotion.prev){ autoDetectChamberMotion.prev = gray.clone(); return null; }
      const diff = new cv.Mat(); cv.absdiff(gray, autoDetectChamberMotion.prev, diff); gray.copyTo(autoDetectChamberMotion.prev);
      cv.GaussianBlur(diff, diff, new cv.Size(7,7), 0);
      const th=new cv.Mat(); cv.threshold(diff, th, 25, 255, cv.THRESH_BINARY);
      const kernel=cv.Mat.ones(3,3,cv.CV_8U); cv.morphologyEx(th, th, cv.MORPH_OPEN, kernel); cv.morphologyEx(th, th, cv.MORPH_CLOSE, kernel);
      const contours=new cv.MatVector(); const hierarchy=new cv.Mat(); cv.findContours(th, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      let best=null, bestScore=0; for (let i=0;i<contours.size();i++){ const r=cv.boundingRect(contours.get(i)); const area=r.width*r.height; const aspect=r.height/Math.max(1,r.width); if (area<(gray.rows*gray.cols)*0.002||area>(gray.rows*gray.cols)*0.25) continue; if (aspect<1.8) continue; const score=aspect*Math.sqrt(area); if (score>bestScore){bestScore=score; best=r;}}
      let out=null; if (best){ const padX=Math.round(best.width*0.25), padY=Math.round(best.height*0.1); const x=Math.max(0,best.x-padX); const y=Math.max(0,best.y-padY); const w=Math.min(gray.cols-x,best.width+padX*2); const h=Math.min(gray.rows-y,best.height+padY*2); out={x,y,w,h, conf:0.5}; }
      contours.delete(); hierarchy.delete(); th.delete(); diff.delete(); kernel.delete(); return out;
    }

    // Tracker
    function updateTracker(gray){ if (!roi) return; const r=new cv.Rect(roi.x,roi.y,Math.max(1,roi.w),Math.max(1,roi.h)); if(!searchTemplate){ const inner=new cv.Rect(r.x+Math.floor(r.width*0.3), r.y, Math.max(5,Math.floor(r.width*0.4)), r.height); const roiStrip=gray.roi(inner); searchTemplate=roiStrip.clone(); roiStrip.delete(); searchRect=new cv.Rect(Math.max(0,r.x-Math.floor(r.width*0.35)), Math.max(0,r.y-Math.floor(r.height*0.2)), Math.min(gray.cols-r.x+Math.floor(r.width*0.35), Math.floor(r.width*1.7)), Math.min(gray.rows-r.y+Math.floor(r.height*0.2), Math.floor(r.height*1.4))); return; } const search=gray.roi(searchRect); const result=new cv.Mat(); result.create(search.rows-searchTemplate.rows+1, search.cols-searchTemplate.cols+1, cv.CV_32FC1); cv.matchTemplate(search,searchTemplate,result,cv.TM_CCOEFF_NORMED); const mm=cv.minMaxLoc(result); lastMatchScore=mm.maxVal; const topLeft=mm.maxLoc; const newX=searchRect.x+topLeft.x-Math.floor(roi.w*0.3); const newY=searchRect.y+topLeft.y; roi={x:Math.max(0,Math.min(gray.cols-roi.w,newX)), y:Math.max(0,Math.min(gray.rows-roi.h,newY)), w:roi.w, h:roi.h}; conf=lastMatchScore; search.delete(); result.delete(); const now=performance.now(); if(lastMatchScore<0.45||(now-lastAutoDetectMs)>2500){ searchTemplate.delete(); searchTemplate=null; lastAutoDetectMs=now; } }

    function processLoop(){
      if (!running) return;
      contourRects.length=0;
      const gray=grabGrayFrame(); let display=cv.imread(canvas);
      const mode=$('mode').value; const now=performance.now();

      if (mode==='auto'){
        if (!roi || conf<0.55){
          // Prøv blå-kappe-deteksjon først
          const byColor = detectBlueCapsAndChamber();
          if (byColor){ roi={x:byColor.x,y:byColor.y,w:byColor.w,h:byColor.h}; conf=byColor.conf; searchTemplate&&(searchTemplate.delete(),searchTemplate=null); showBadge('Kammer (blå)'); }
        }
        if (roi) updateTracker(gray);
        if (!roi || conf<0.45){
          const byMotion = autoDetectChamberMotion(gray);
          if (byMotion){ roi={x:byMotion.x,y:byMotion.y,w:byMotion.w,h:byMotion.h}; conf=Math.max(conf, byMotion.conf); showBadge('Kammer (bevegelse)'); }
        }
      } else {
        if (!roi){ const w=canvas.width,h=canvas.height; const rw=Math.round(w*0.22), rh=Math.round(h*0.78); const rx=Math.round((w-rw)/2), ry=Math.round((h-rh)/2); roi={x:rx,y:ry,w:rw,h:rh}; conf=0.5; setStatus('Manuell modus: plasser kammeret i rammen.'); }
      }

      // Telling i ROI
      lineYCache=null;
      if (roi){
        const r=new cv.Rect(roi.x,roi.y,Math.max(1,roi.w),Math.max(1,roi.h)); const roiGray=gray.roi(r);
        // Kontrastforbedring (CLAHE) for klare dråper
        const clahe=cv.createCLAHE(2.0, new cv.Size(8,8)); clahe.apply(roiGray, roiGray); clahe.delete();
        if(!lastFrameROI||lastFrameROI.cols!==roiGray.cols||lastFrameROI.rows!==roiGray.rows){ if(lastFrameROI) lastFrameROI.delete(); lastFrameROI=roiGray.clone(); }
        const diff=new cv.Mat(); cv.absdiff(roiGray,lastFrameROI,diff); roiGray.copyTo(lastFrameROI);
        const th=new cv.Mat(); cv.GaussianBlur(diff,diff,new cv.Size(5,5),0); cv.threshold(diff,th,20,255,cv.THRESH_BINARY);
        const kernel=cv.Mat.ones(3,3,cv.CV_8U); cv.morphologyEx(th,th,cv.MORPH_OPEN,kernel); cv.morphologyEx(th,th,cv.MORPH_CLOSE,kernel);
        const contours=new cv.MatVector(); const hierarchy=new cv.Mat(); cv.findContours(th,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
        const lineY=roi.y+Math.round(roi.h*0.6); lineYCache=lineY; const nowMs=performance.now();
        for(let i=0;i<contours.size();i++){ const rect=cv.boundingRect(contours.get(i)); const area=rect.width*rect.height; if(area<20||rect.height<6||rect.height>roi.h*0.6) continue; const cx=rect.x+rect.width/2+roi.x; const cy=rect.y+rect.height/2+roi.y; contourRects.push({x:rect.x+roi.x,y:rect.y+roi.y,w:rect.width,h:rect.height,cx,cy}); if(Math.abs(cy-lineY)<=5){ if(nowMs-lastDropMs>=minIntervalMs){ if(window._prevEventMs===undefined) window._prevEventMs=nowMs; else { const dt=nowMs-window._prevEventMs; window._prevEventMs=nowMs; if(dt>=150&&dt<=8000){ intervals.push(dt); if(intervals.length>10) intervals.shift(); const instDpm=60000.0/dt; emaDpm=(emaDpm==null)?instDpm:(0.2*instDpm+0.8*emaDpm); } } drops+=1; lastDropMs=nowMs; updateMetrics(); flashMs=220; lastBlob={cx,cy,rect:{x:rect.x+roi.x,y:rect.y+roi.y,w:rect.width,h:rect.height}}; } } }
        contours.delete(); hierarchy.delete(); kernel.delete(); th.delete(); diff.delete(); roiGray.delete();
      }

      // vis video
      cv.imshow(canvas, display); display.delete(); gray.delete();

      const g=canvas.getContext('2d');
      // (valgfri) vis maske – slå av som standard
      if ($('showMask').checked && autoDetectChamberMotion.prev){ try{ const tmp=document.createElement('canvas'); tmp.width=offscreenMask.width; tmp.height=offscreenMask.height; const w=Math.round(canvas.width*0.22); const h=Math.round(offscreenMask.height*(w/offscreenMask.width)); g.save(); g.globalAlpha=0.8; g.drawImage(offscreenMask, 10, 10, w, h); g.restore(); }catch{}}
      // tegn konturer
      if ($('showContours').checked){ for(const r of contourRects){ g.save(); g.strokeStyle='rgba(0,200,255,.95)'; g.lineWidth=2; g.strokeRect(r.x,r.y,r.w,r.h); g.beginPath(); g.arc(r.cx,r.cy,5,0,Math.PI*2); g.stroke(); g.restore(); } }
      // ROI + linje
      if (roi){ g.save(); g.strokeStyle=confColor(); g.lineWidth=4; g.strokeRect(roi.x,roi.y,roi.w,roi.h); if(lineYCache!=null){ g.strokeStyle='rgba(0,255,255,.95)'; g.beginPath(); g.moveTo(roi.x,lineYCache); g.lineTo(roi.x+roi.w,lineYCache); g.stroke(); } g.restore(); }
      // flash
      if (flashMs>0){ g.save(); g.fillStyle='rgba(56,214,107,0.18)'; g.fillRect(0,0,canvas.width,canvas.height); if(lastBlob){ const t=1-(flashMs/220); const radius=10+t*60; g.beginPath(); g.arc(lastBlob.cx,lastBlob.cy,radius,0,Math.PI*2); g.strokeStyle='rgba(56,214,107,'+(0.9*(1-t))+')'; g.lineWidth=3; g.stroke(); } g.restore(); flashMs-=16; }
      updateCorner();

      if (counting) requestAnimationFrame(processLoop); else running=false;
    }

    function toggleCounting(){ if(!stream) return; counting=!counting; $('btnToggle').textContent=counting?'Pause':'Start'; if(counting){ running=true; requestAnimationFrame(processLoop);} }
    function resetAll(){ drops=0; emaDpm=null; intervals.length=0; lastDropMs=0; window._prevEventMs=undefined; updateMetrics(); searchTemplate&&searchTemplate.delete(); searchTemplate=null; roi=null; setStatus('Nullstilt.'); lastBlob=null; flashMs=0; conf=0; contourRects.length=0; }

    function onOpenCvReady(){ window.onOpenCvReady = () => setStatus('OpenCV.js lastet. Start kamera.'); }

    // init UI
    window.addEventListener('DOMContentLoaded', () => {
      video=$('video'); canvas=$('canvas'); ctx=canvas.getContext('2d');
      $('btnStart').onclick = async()=>{ await startCamera(); counting=true; running=true; updateSensitivity(); requestAnimationFrame(processLoop); };
      $('btnToggle').onclick = toggleCounting; $('btnReset').onclick = resetAll;
      $('dropFactor').onchange = updateMetrics; $('sensitivity').onchange = updateSensitivity; $('facing').onchange = startCamera;
      $('mode').onchange = ()=>{ roi=null; searchTemplate&&searchTemplate.delete(); searchTemplate=null; setStatus($('mode').value==='auto'?'Auto-modus aktiv.':'Manuell modus: plasser kammeret i rammen.'); };
    });
  </script>
</body>
</html>
